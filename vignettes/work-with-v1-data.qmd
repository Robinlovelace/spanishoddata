---
title: "Working with v1 MITMA data"
vignette: >
  %\VignetteIndexEntry{Working with v1 MITMA data}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
execute: 
  eval: false
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
#| eval: false
if (!requireNamespace(c("pak"), quietly = TRUE)) {
  install.packages("pak")
}
packages <- c("sf", "dplyr", "DBI")
pak::pkg_install(packages, ask = FALSE, upgrade = FALSE)

pak::pkg_install("Robinlovelace/spanishoddata@1a53ed9f834f720f47cb016769464acfdad599a8", ask = FALSE, upgrade = TRUE)
```

```{r setup}
#| include: false
library(sf)
library(dplyr)
library(DBI)
library(spanishoddata)
```

# Introduction

v1 MITMA data covers the period from 2020-02-14 to 2021-05-09. Add references...

# Set a directory to store the data

```{r eval=FALSE}
#| eval: false
Sys.setenv(SPANISH_OD_DATA_DIR = "path/to/store/data")
spod_get_data_dir() # you may want to check that it is set correctly
```


# Get the zones

Load the spatial data for districts.

```{r}
districts <- spod_get_zones_v1(zones = "dist", quiet = TRUE)
```

```{r}
glimpse(districts)
plot(st_geometry(districts))
```

Load the spatial data for municipalities.

```{r}
municipalities <- spod_get_zones_v1(zones = "muni", quiet = TRUE)
```

```{r}
glimpse(municipalities)
plot(st_geometry(municipalities))
```

# Get the origin-destination data for an inteval of dates

Load the data for the period from 2020-02-14 to 2020-02-17.

The data will be cached in the directory set in the SPANISH_OD_DATA_DIR environment variable. If it is already downloaded, it will not be downloaded again.

```{r}
od_dist_1 <- spod_get_od_v1(
  zones = "dist",
  dates = c(start = "2020-02-14", end = "2020-02-17"),
  quiet = TRUE
)
```


Look at the data structure. This is a lazy table with DuckDB backend. That is, the files on disk are still raw gzipped CSV files, but they are cleverly connected to a dynamic view in in-memory DuckDB database.

```{r}
od_dist_1 |> glimpse()
```

You can work with it using dplyr verbs as if it were a regular data frame, but if you want to load the results into memory, you can use the `collect()` function.

For example this code below will not execute the query, but will only create another "lazy" object.

```{r}
od_dist_1_lazy <- od_dist_1 |>
  group_by(id_origin, id_destination, full_date) |>
  summarise(
    total_day_trips = sum(n_trips, na.rm = TRUE),
    .groups = "drop"
  ) |>
  group_by(id_origin, id_destination) |>
  summarise(
    mean_dayly_trips = mean(total_day_trips, na.rm = TRUE),
    .groups = "drop"
  )
```

In fact this is a "lazy" object with an SQL query attached to it. You can see the query with the `show_query()` function.

```{r}
od_dist_1_lazy |> show_query()
```

```{r}
format(object.size(od_dist_1_lazy), units = "Mb")
class(od_dist_1_lazy)
```

If you want to load the results into memory, you can use the `collect()` function. It can be added either at the end of the original pipeline, like so:

```{r}
#| eval=FALSE
od_dist_1_data <- od_dist_1 |>
  group_by(id_origin, id_destination, full_date) |>
  summarise(
    total_day_trips = sum(n_trips, na.rm = TRUE),
    .groups = "drop"
  ) |>
  group_by(id_origin, id_destination) |>
  summarise(
    mean_dayly_trips = mean(total_day_trips, na.rm = TRUE),
    .groups = "drop"
  ) |>
  collect()
```

Or you can just add collect() to the "lazy" object that you created before, like so:

```{r}
od_dist_1_data <- od_dist_1_lazy |> collect()
```

```{r}
format(object.size(od_dist_1_data), units = "Mb")
class(od_dist_1_data)
```

To safely disconnect the in-memory database, you can use the `DBI::dbDisconnect()` function.

```{r}
DBI::dbDisconnect(od_dist_1$src$con)
```

# Get the origin-destination data for several non-consecutive dates

This time let's get the data for 2020-02-14, 2020-02-17, 2021-05-07 and 2021-05-09. We will use municipalities as zones.

```{r}
od_muni_1 <- spod_get_od_v1(
  zones = "muni",
  dates = c("2020-02-14", "2020-02-17", "2021-05-07", "2021-05-09"),
  quiet = TRUE
)
```


Look at the data structure.

```{r}
od_muni_1 |> glimpse()
```

```{r}
format(object.size(od_muni_1), units = "Mb")
class(od_muni_1)
```

```{r}
DBI::dbDisconnect(od_muni_1$src$con)
```
